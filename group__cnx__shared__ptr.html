<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Memory &raquo; CnxSharedPtr module | Cnx A Proof-of-Concept For A Modern Standard Library for GNU C23</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Cnx <span class="m-thin">A Proof-of-Concept For A Modern Standard Library for GNU C23</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li><a href="annotated.html">Classes</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="group__memory.html">Memory</a> &raquo;</span>
          CnxSharedPtr <span class="m-thin">module</span></h1>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              <a href="#autotoc_md14">Instantiation Requirements:</a>
              <ul>
                <li><a href="#autotoc_md15">Instantiation Mode Parameters</a></li>
                <li><a href="#autotoc_md16">Template Parameters</a></li>
              </ul>
            </li>
            <li>
              Reference
              <ul>
                <li><a href="#define-members">Defines</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> is a struct template similar to C++&#x27;s <code>std::shared_ptr</code> or Rust&#x27;s <code>Box</code> for a &quot;smart&quot; pointer type that maintains (when used correctly) shared ownership of, and manages an object through, a contained pointer. The shared object is disposed of (&quot;freed&quot;) when all <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>s sharing its ownership have been explicitly freed, when all owners have gone out of scope when declared with the <code><a href="group__cnx__shared__ptr.html#ga5dd81ba393e3fe464ddf9c23194b9c8e" class="m-doc">shared_<wbr />scoped(T)</a></code> tagged declaration, when <code>reset</code> (<code>cnx_shared_ptr_reset</code>) has been called on all owners, or some combination thereof.</p><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> is allocator aware and stores its associated allocator in itself.</p><p>The contained object is &quot;freed&quot; by a <code>CnxDeleter</code>, a function taking a <code>T*</code> and a <code><a href="structCnxAllocator.html" class="m-doc">CnxAllocator</a></code>, whose task is to properly cleanup/free/etc. anything associated with the <code>T</code>. This deleter can be supplied as a template parameter, <code>SHARED_DELETER</code> when instantiating the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> template. This template parameter is optional, and if not supplied the deleter used will be the default deleter, which will simply deallocate the <code>T</code> with the allocator associated with the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instance.</p><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> can own dynamically allocated array types, and provided functionality will be slightly different, though comparable, when <code>T</code> is an array type vs a singular type. To instantiate the template for an array type, the type must be <code>typedef</code>ed, e.g.: <code>typedef int int_arr[];</code>, and the typedef provided as the <code>SHARED_T</code> template parameter.</p><section id="autotoc_md14"><h2><a href="#autotoc_md14">Instantiation Requirements:</a></h2><ol><li>a <code>typedef</code> of your type to to provide an alphanumeric name for it (so it can be used in template and macro parameters)</li></ol><p>We recommend two routes for providing instantations for user-defined types, either:</p><ol><li>Provide the instantiation together with your type&#x27;s public interface and implementation OR</li><li>Provide it as a separate &quot;template instantiation&quot; .h/.c file pair.</li></ol><p>We recommend option one when your type is typically used in tandem with the template instantation or if it requires it for its public interface. We recommend option two for all other circumstances, so that users don&#x27;t pay the price (compile time, and potentially code size) of template instantiations if they don&#x27;t use them.</p><section id="autotoc_md15"><h3><a href="#autotoc_md15">Instantiation Mode Parameters</a></h3><p>These signal to the implementation to instantiation the declarations, definitions, or both, for the template.</p><ol><li><code>SHARED_DECL</code> (Optional) - Defining this to true signals to the implementation to declare the required type declarations and definitions, and any required or public function declarations when you include <code>&lt;<a href="SharedPtr_8h.html" class="m-doc">Cnx/<wbr />SharedPtr.h</a>&gt;</code>. No functions will be defined. This is optional (but signals intent explicitly) - If required template parameters are defined and <code>SHARED_DECL</code> is not, then this will be inferred as true by default.</li><li><code>SHARED_IMPL</code> - Defining this to true signals to the implementation to define the functions necessary for the template instantation when you include <code>&lt;<a href="SharedPtr_8h.html" class="m-doc">Cnx/<wbr />SharedPtr.h</a>&gt;</code>. This is not required to be paired with <code>SHARED_DECL</code> (you can declare the template, in a header for example, prior to defining it in a source file), but it is eventually required to be used in exactly one translation unit in the resulting binary in order to provide definitions for the template&#x27;s functions. Failing to complete this instantiation-mode exactly once in exactly one translation unit in your build will cause linking errors due to missing or multiply defined functions.</li></ol></section><section id="autotoc_md16"><h3><a href="#autotoc_md16">Template Parameters</a></h3><p>These provide the type or value parameters that the template is parameterized on to the template implementation. These should be <code>#define</code>d to their appropriate types/values.</p><ol><li><code>SHARED_T</code> - The type to be stored and managed in the shared_ptr (e.g. <code>u32</code> or <code><a href="structCnxString.html" class="m-doc">CnxString</a></code>). This is required.</li><li><code>SHARED_DELETER</code> - The deleter function to free the memory associated with the managed type and perform any necessary associated cleanup. This function must take a particular signature: For a type <code>Y</code> that evaluates to either:</li></ol><ol><li><code>T</code> (<code>SHARED_T</code>) if <code>T</code> is <strong>NOT</strong> an array type</li><li>The element type of the array type <code>T</code> if <code>T</code> <strong>IS</strong> an array type. e.g. for an array type <code>T</code>, and an instance <code>t</code>, <code>Y</code> would be <code><a href="group__cnx__def.html#ga64f556323b092e639c2e86743ebc852d" class="m-doc">typeof(t[0])</a></code></li></ol><p>The signature must be <code>void name(Y* object, CnxAllocator allocator);</code> where <code>object</code> is a pointer to the managed object and <code>allocator</code> is the allocator associated with the object (the one that allocated it, and will free it).</p><p>Example using instantiation method one:</p><pre class="m-code"><span class="c1">// in MyStruct.h</span>

<span class="c1">// include for `TRUE` (could just use `1`)</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/Def.h&gt;</span><span class="cp"></span>
<span class="c1">// include for `i32`</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/BasicTypes.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">i32</span> <span class="n">one</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">two</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">three</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyStruct</span><span class="p">;</span>

<span class="c1">// instantiate `CnxSharedPtr(MyStruct)` declaration</span>
<span class="cp">#define SHARED_T MyStruct</span>
<span class="cp">#define SHARED_DECL TRUE</span>
<span class="cp">#define SHARED_UNDEF_PARAMS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/SharedPtr.h&gt;</span><span class="cp"></span>
<span class="cp">#undef SHARED_UNDEF_PARAMS</span>

<span class="c1">// in MyStruct.c</span>

<span class="cp">#include</span> <span class="cpf">&quot;MyStruct.h&quot;</span><span class="cp"></span>

<span class="c1">// instantiate `CnxSharedPtr(MyStruct)` declaration</span>
<span class="cp">#define SHARED_T MyStruct</span>
<span class="cp">#define SHARED_IMPL TRUE</span>
<span class="cp">#define SHARED_UNDEF_PARAMS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/SharedPtr.h&gt;</span><span class="cp"></span>
<span class="cp">#undef SHARED_UNDEF_PARAMS</span>

<span class="kt">void</span> <span class="nf">takes_ownership</span><span class="p">(</span><span class="n">CnxSharedPtr</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">to_take</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// create a sharedly owned `MyStruct`</span>
    <span class="n">shared_scoped</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="n">cnx_make_shared</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">,</span> <span class="p">.</span><span class="n">one</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">two</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="p">.</span><span class="n">three</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// transfer ownership of the `MyStruct` object managed by `my_ptr` to `takes_ownership`</span>
    <span class="c1">// `my_ptr` now contains `nullptr`</span>
    <span class="n">takes_ownership</span><span class="p">(</span><span class="n">ptr_move</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">));</span>

    <span class="c1">// aside: `ptr_move` from is nearly equivalent to `move`, but it ensures that the contained</span>
    <span class="c1">// pointer is set to the correct `nullptr` constant (`NULL` is not necessarily 0 on all</span>
    <span class="c1">// platforms, and `move` is implemented with zero-setting on the moved-from value).</span>
    <span class="c1">// on platforms where `NULL` is guaranteed to be `0`, you can safely use `move` instead of</span>
    <span class="c1">// `ptr_move`</span>
<span class="p">}</span></pre><p>Example using instantiation method two:</p><pre class="m-code"><span class="c1">// in MyStruct.h</span>

<span class="c1">// include for `i32`</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/BasicTypes.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">i32</span> <span class="n">one</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">two</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">three</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyStruct</span><span class="p">;</span>


<span class="c1">// in CnxSharedPtrMyStruct.h</span>

<span class="c1">// include for `TRUE` (could just use `1`)</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/Def.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;MyStruct.h&quot;</span><span class="cp"></span>

<span class="c1">// instantiate `CnxSharedPtr(MyStruct)` declaration</span>
<span class="cp">#define SHARED_T MyStruct</span>
<span class="cp">#define SHARED_DECL TRUE</span>
<span class="cp">#define SHARED_UNDEF_PARAMS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/SharedPtr.h&gt;</span><span class="cp"></span>
<span class="cp">#undef SHARED_UNDEF_PARAMS</span>

<span class="c1">// in CnxSharedPtrMyStruct.c</span>

<span class="cp">#include</span> <span class="cpf">&quot;CnxSharedPtrMyStruct.h&quot;</span><span class="cp"></span>

<span class="c1">// instantiate `CnxSharedPtr(MyStruct)` declaration</span>
<span class="cp">#define SHARED_T MyStruct</span>
<span class="cp">#define SHARED_IMPL TRUE</span>
<span class="cp">#define SHARED_UNDEF_PARAMS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/SharedPtr.h&gt;</span><span class="cp"></span>
<span class="cp">#undef SHARED_UNDEF_PARAMS</span>

<span class="c1">// in MyStruct.c</span>

<span class="kt">void</span> <span class="nf">takes_ownership</span><span class="p">(</span><span class="n">CnxSharedPtr</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">to_take</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// create a sharedly owned `MyStruct`</span>
    <span class="n">shared_scoped</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="n">cnx_make_shared</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">,</span> <span class="p">.</span><span class="n">one</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">two</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="p">.</span><span class="n">three</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// transfer ownership of the `MyStruct` object managed by `my_ptr` to `takes_ownership`</span>
    <span class="c1">// `my_ptr` now contains `nullptr`</span>
    <span class="n">takes_ownership</span><span class="p">(</span><span class="n">ptr_move</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">));</span>

    <span class="c1">// aside: `ptr_move` from is nearly equivalent to `move`, but it ensures that the contained</span>
    <span class="c1">// pointer is set to the correct `nullptr` constant (`NULL` is not necessarily 0 on all</span>
    <span class="c1">// platforms, and `move` is implemented with zero-setting on the moved-from value).</span>
    <span class="c1">// on platforms where `NULL` is guaranteed to be `0`, you can safely use `move` instead of</span>
    <span class="c1">// `ptr_move`</span>
<span class="p">}</span></pre><p>Like other Cnx templates, <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> provides its type-agnostic usage through a vtable pointer contained in the struct, and provides macros which wrap usage of the vtable, making access simpler. If you prefer to not use this method of access, you can call the typed functions directly by in-fixing the contained type in the associated function name. IE: for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(i32)</a></code>, <code>i32_ptr</code>, the equivalent function call for <code>cnx_shared_ptr_release</code> would be <code>cnx_shared_ptr_i32_release(&amp;i32_ptr)</code>.</p><aside class="m-note m-info"><h4>Note</h4><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> uses a combination of Clang&#x27;s <code>diagnose_if</code> attribute, static_asserts, and runtime asserts to disable the use of functions that only apply to non-array or array-type <code>T</code>s, respectively, when <code>T</code> is not the correct type category. This provides compile-time errors in as many situations as possible. However, when compiling with something other than Clang forgoing the macros bypasses the only compile-time checks available (static_asserts), resulting in runtime asserts being the only defense against invoking undefined behavior from calling an array-associated function for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instantiation where <code>T</code> is not an array-type. Because of this, it&#x27;s particularly discouraged to forgo the function-like macros for <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>, or any Cnx smart pointer, for that matter.</p></aside></section></section>
        <section id="define-members">
          <h2><a href="#define-members">Defines</a></h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr</a>(</span><span class="m-doc-wrap">T)</span>
            </dt>
            <dd>macro alias for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> maintaining ownership of an allocated <code>T</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaae63389bf3472f2ae48854541cede85a" class="m-doc">cnx_shared_ptr_new</a>(</span><span class="m-doc-wrap">T)</span>
            </dt>
            <dd>Creates a new sharedly, owned zero-initialized <code>T</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaa4b5a5ec571f8252db0260eb2f048bd1" class="m-doc">cnx_shared_ptr_new_with_allocator</a>(</span><span class="m-doc-wrap">T,
              allocator)</span>
            </dt>
            <dd>Creates a new sharedly owned, zero-initialized <code>T</code>, allocated with the given allocator.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaaf702e4be1ce33f52394e26ee087643a" class="m-doc">cnx_shared_ptr_new_with_capacity</a>(</span><span class="m-doc-wrap">T,
              capacity)</span>
            </dt>
            <dd>Creates a new sharedly owned, zero-initialized, dynamically allocated array.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga8ee40b4112448e321204c5c9fd031954" class="m-doc">cnx_shared_ptr_new_with_capacity_and_allocator</a>(</span><span class="m-doc-wrap">T,
              capacity,
              allocator)</span>
            </dt>
            <dd>Creates a new sharedly owned, zero-initialized, dynamically allocated array, allocated with the given allocator.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaa8d8c1111475a68953a54008f159a975" class="m-doc">cnx_shared_ptr_from</a>(</span><span class="m-doc-wrap">T,
              ptr)</span>
            </dt>
            <dd>Creates a new <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga7c6ec672925905483156c42db42de0c0" class="m-doc">cnx_shared_ptr_from_with_allocator</a>(</span><span class="m-doc-wrap">T,
              ptr,
              allocator)</span>
            </dt>
            <dd>Creates a new <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer, associated with the given allocator.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gac266ee041af60e3e1c0e71e5f32d2e0a" class="m-doc">cnx_shared_ptr_free</a>(</span><span class="m-doc-wrap">T,
              self)</span>
            </dt>
            <dd>Frees the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>, calling the associated deleter on the managed object.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga451b303776892f820c2a0cfc5bf5397b" class="m-doc">cnx_shared_ptr_release</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Releases the pointer managed by <code>self</code> from ownership.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga73638203b8f1c0e8c3c354616c2dc834" class="m-doc">cnx_shared_ptr_reset</a>(</span><span class="m-doc-wrap">self,
              new_ptr)</span>
            </dt>
            <dd>Frees the object currently managed by <code>self</code>, and replaces it with the one pointed to by <code>new_ptr</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gafd92b58165ad7da0a21898a9c8af19cb" class="m-doc">cnx_shared_ptr_clone</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Clones the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga81220e99933dc28fb26c69b55bf0108d" class="m-doc">cnx_shared_ptr_swap</a>(</span><span class="m-doc-wrap">self,
              other_ptr)</span>
            </dt>
            <dd>Swaps the managed objects of <code>self</code> and the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> pointed to by <code>other_ptr</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga976b2abe93731d39e7b0f5d6f451dee0" class="m-doc">cnx_shared_ptr_get_deleter</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Returns the <code><a href="group__cnx__smart__ptrs.html#ga9290669aabf1ea806c11f2252812bf61" class="m-doc">CnxDeleter(T)</a></code> function pointer associated with the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instantiation <code>self</code> is an instance of.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga69ed28fc3ca608dc7a0a8895a57d5b4d" class="m-doc">cnx_shared_ptr_as_bool</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Returns whether the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> currently manages an object.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga1cbad558e109833820dbf0c6599f4d19" class="m-doc">cnx_shared_ptr_get</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Returns a pointer to the object managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gab404c858c7598af460abaeaef0e83d1c" class="m-doc">cnx_shared_ptr_get_const</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Returns a pointer-to-const to the object managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga820a4ceb9b1eec362fe5127851e57add" class="m-doc">cnx_shared_ptr_get_mut</a>(</span><span class="m-doc-wrap">self)</span>
            </dt>
            <dd>Returns a pointer-to-non-const to the object managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaf410eb61630d54f499318fb54404d41d" class="m-doc">cnx_shared_ptr_at</a>(</span><span class="m-doc-wrap">self,
              index)</span>
            </dt>
            <dd>Returns a reference to the element at <code>index</code> in the array managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga47d81a12f9dc2fe7a23842e3ef14f4bf" class="m-doc">cnx_shared_ptr_at_const</a>(</span><span class="m-doc-wrap">self,
              index)</span>
            </dt>
            <dd>Returns a reference-to-const to the element at <code>index</code> in the array managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga12bad1b5b231a878405f74e3fbaa641e" class="m-doc">cnx_shared_ptr_at_mut</a>(</span><span class="m-doc-wrap">self,
              index)</span>
            </dt>
            <dd>Returns a reference-to-non-const to the element at <code>index</code> in the array managed by <code>self</code></dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga8a8c2a548c8eb80ebdd8217dce504c00" class="m-doc">cnx_make_shared</a>(</span><span class="m-doc-wrap">T,
              ...)</span>
            </dt>
            <dd>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a <code>T</code> initialized with the given list of (potentially designated) initializers.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga61f957c3bfb3818815ae75e9419952ed" class="m-doc">cnx_make_shared_with_allocator</a>(</span><span class="m-doc-wrap">T,
              allocator,
              ...)</span>
            </dt>
            <dd>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a <code>T</code> initialized with the given list of (potentially designated) initializers, allocated with the given allocator.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gae6e39a0e9f1e4f8e15411253b7ad4f03" class="m-doc">cnx_make_shared_array</a>(</span><span class="m-doc-wrap">T,
              capacity)</span>
            </dt>
            <dd>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the array type <code>T</code> with the given initial capacity.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#gaac99cb7ff1c1f18308a59f9e9a620cb4" class="m-doc">cnx_make_shared_array_with_allocator</a>(</span><span class="m-doc-wrap">T,
              capacity,
              allocator)</span>
            </dt>
            <dd>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the array type <code>T</code> with the given initial capacity, allocated with the given allocator.</dd>
            <dt>
              <span class="m-doc-wrap-bumper">#define <a href="#ga5dd81ba393e3fe464ddf9c23194b9c8e" class="m-doc">shared_scoped</a>(</span><span class="m-doc-wrap">T)</span>
            </dt>
            <dd>Declare a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> with this declaration attribute/type to ensure it (and its managed object) is automatically freed when the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> goes out of scope.</dd>
          </dl>
        </section>
        <section>
          <h2>Define documentation</h2>
          <section class="m-doc-details" id="ga31a460baee7771717b4a1b7d39426338"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga31a460baee7771717b4a1b7d39426338" class="m-doc-self">CnxSharedPtr</a>(</span><span class="m-doc-wrap">T)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>macro alias for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> maintaining ownership of an allocated <code>T</code></p>
<p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> is a template for a &quot;smart&quot; pointer type that maintains (when used correctly) shared ownership of and manages an object through a contained pointer. The contained object is disposed of (&quot;freed&quot;) when the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> is explicitly freed, when it goes out of scope when declared with the <code><a href="group__cnx__shared__ptr.html#ga5dd81ba393e3fe464ddf9c23194b9c8e" class="m-doc">shared_<wbr />scoped(T)</a></code> tagged declaration, or when <code>reset</code> (<code>Cnx_shared_ptr_reset</code>) is called on the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>.</p><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> is allocator aware and stores its associated allocator in itself.</p><p>The contained object is &quot;freed&quot; by a <code>CnxDeleter</code>, a function taking a <code>T*</code> and a <code><a href="structCnxAllocator.html" class="m-doc">CnxAllocator</a></code>, whose task is to properly cleanup/free/etc. anything associated with the <code>T</code>. This deleter can be supplied as a template parameter, <code>SHARED_DELETER</code> when instantiating the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> template. This template parameter is optional, and if not supplied the deleter used will be the default deleter, which will simply deallocate the <code>T</code> with the allocator associated with the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instance.</p><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> can own dynamically allocated array types, and provided functionality will be slightly different, though comparable, when <code>T</code> is an array type or a singular type. To instantiate the template for an array type, the type must be <code>typedef</code>ed, e.g.: <code>typedef int int_arr[];</code>, and the typedef provided as the <code>SHARED_T</code> template parameter.</p><p>Example:</p><pre class="m-code"><span class="c1">// include for `TRUE`</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/Def.h&gt;</span><span class="cp"></span>
<span class="c1">// include for `i32`</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/BasicTypes.h&gt;</span><span class="cp"></span>

<span class="c1">// just for example&#39;s sake</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">i32</span> <span class="n">one</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">two</span><span class="p">;</span>
    <span class="n">i32</span> <span class="n">three</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyStruct</span><span class="p">;</span>

<span class="c1">// instantiate `CnxSharedPtr(MyStruct)`</span>
<span class="cp">#define SHARED_T MyStruct</span>
<span class="cp">#define SHARED_DECL TRUE</span>
<span class="cp">#define SHARED_IMPL TRUE</span>
<span class="cp">#define SHARED_UNDEF_PARAMS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/SharedPtr.h&gt;</span><span class="cp"></span>
<span class="cp">#undef SHARED_UNDEF_PARAMS</span>

<span class="kt">void</span> <span class="nf">takes_ownership</span><span class="p">(</span><span class="n">CnxSharedPtr</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">to_take</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// create a sharedly owned `MyStruct`</span>
    <span class="n">shared_scoped</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">)</span> <span class="n">my_ptr</span> <span class="o">=</span> <span class="n">cnx_make_shared</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">,</span> <span class="p">.</span><span class="n">one</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">two</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="p">.</span><span class="n">three</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// transfer ownership of the `MyStruct` object managed by `my_ptr` to `takes_ownership`</span>
    <span class="c1">// `my_ptr` now contains `nullptr`</span>
    <span class="n">takes_ownership</span><span class="p">(</span><span class="n">ptr_move</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">));</span>
<span class="p">}</span></pre><p>Like other Cnx templates, <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> provides its type-agnostic usage through a vtable pointer contained in the struct, and provides macros which wrap usage of the vtable, making access simpler. If you prefer to not use this method of access, you can call the typed functions directly by in-fixing the contained type in the associated function name. IE: for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(i32)</a></code>, <code>i32_ptr</code>, the equivalent function call for <code>cnx_shared_ptr_release</code> would be <code>cnx_shared_ptr_i32_release(&amp;i32_ptr)</code>.</p><aside class="m-note m-info"><h4>Note</h4><p><code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> uses a combination of Clang&#x27;s <code>diagnose_if</code> attribute, static_asserts, and runtime asserts to disable the use of functions that only apply to non-array or array-type <code>T</code>s, respectively, when <code>T</code> is not the correct type category. This provides compile-time errors in as many situations as possible. However, when compiling with something other than Clang forgoing the macros bypasses the only compile-time checks available (static_asserts), resulting in runtime asserts being the only defense against invoking undefined behavior from calling an array-associated function for a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instantiation where <code>T</code> is not an array-type. Because of this, it&#x27;s particularly discouraged to forgo the function-like macros for <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>, or any Cnx smart pointer, for that matter.</p></aside>
          </div></section>
          <section class="m-doc-details" id="gaae63389bf3472f2ae48854541cede85a"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaae63389bf3472f2ae48854541cede85a" class="m-doc-self">cnx_shared_ptr_new</a>(</span><span class="m-doc-wrap">T)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new sharedly, owned zero-initialized <code>T</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a zero-initialized <code>T</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Only enabled when <code>T</code> is NOT an array type. To create a zero-initialized sharedly-owned dynamic array, use <code>cnx_shared_ptr_new_with_capacity</code></p></aside>
          </div></section>
          <section class="m-doc-details" id="gaa4b5a5ec571f8252db0260eb2f048bd1"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaa4b5a5ec571f8252db0260eb2f048bd1" class="m-doc-self">cnx_shared_ptr_new_with_allocator</a>(</span><span class="m-doc-wrap">T,
              allocator)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new sharedly owned, zero-initialized <code>T</code>, allocated with the given allocator.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
                <tr>
                  <td>allocator</td>
                  <td>- The allocator to allocator and eventually free the managed <code>T</code> with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a zero-initialized <code>T</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Only enabled when <code>T</code> is NOT an array type. To create a zero-initialized sharedly-owned dynamic array with an associated allocator, use <code>cnx_shared_ptr_new_with_capacity_and_allocator</code></p></aside>
          </div></section>
          <section class="m-doc-details" id="gaaf702e4be1ce33f52394e26ee087643a"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaaf702e4be1ce33f52394e26ee087643a" class="m-doc-self">cnx_shared_ptr_new_with_capacity</a>(</span><span class="m-doc-wrap">T,
              capacity)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new sharedly owned, zero-initialized, dynamically allocated array.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The array type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>. Must be a typedef to an array type (e.g.: <code>typedef i32 i32_array[];</code>).</td>
                </tr>
                <tr>
                  <td>capacity</td>
                  <td>- The capacity of the array, in number of elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a zero-initialized, dynamically allocated array.</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Only enabled when <code>T</code> is an array type. To create a single zero-initialized, sharedly-owned object, use <code>cnx_shared_ptr_new</code></p></aside>
          </div></section>
          <section class="m-doc-details" id="ga8ee40b4112448e321204c5c9fd031954"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga8ee40b4112448e321204c5c9fd031954" class="m-doc-self">cnx_shared_ptr_new_with_capacity_and_allocator</a>(</span><span class="m-doc-wrap">T,
              capacity,
              allocator)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new sharedly owned, zero-initialized, dynamically allocated array, allocated with the given allocator.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The array type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>. Must be a typedef to an array type (e.g.: <code>typedef i32 i32_array[];</code>).</td>
                </tr>
                <tr>
                  <td>capacity</td>
                  <td>- The capacity of the array, in number of elements</td>
                </tr>
                <tr>
                  <td>allocator</td>
                  <td>- The allocator to allocator and eventually free the managed array with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a zero-initialized, dynamically allocated array.</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Only enabled when <code>T</code> is an array type. To create a single zero-initialized, sharedly-owned object with an associated allocator, use <code>cnx_shared_ptr_new_with_allocator</code></p></aside>
          </div></section>
          <section class="m-doc-details" id="gaa8d8c1111475a68953a54008f159a975"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaa8d8c1111475a68953a54008f159a975" class="m-doc-self">cnx_shared_ptr_from</a>(</span><span class="m-doc-wrap">T,
              ptr)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
                <tr>
                  <td>ptr</td>
                  <td>- The ptr to manage with the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>.</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer</td>
                </tr>
              </tfoot>
            </table>
<p><code>T</code> may be either an array type or a single object.</p><p>Useful when working with a legacy API that returns raw allocated object(s), but you still want use a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to maintain ownership. If you have control over when allocation occurs, prefer <code>cnx_shared_ptr_new</code>, <code>cnx_make_shared</code>, or derivatives.</p>
          </div></section>
          <section class="m-doc-details" id="ga7c6ec672925905483156c42db42de0c0"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga7c6ec672925905483156c42db42de0c0" class="m-doc-self">cnx_shared_ptr_from_with_allocator</a>(</span><span class="m-doc-wrap">T,
              ptr,
              allocator)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a new <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer, associated with the given allocator.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type to manage in the created <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
                <tr>
                  <td>ptr</td>
                  <td>- The ptr to manage with the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>.</td>
                </tr>
                <tr>
                  <td>allocator</td>
                  <td>- The allocator to allocator and eventually free the managed <code>T</code> with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the given pointer</td>
                </tr>
              </tfoot>
            </table>
<p><code>T</code> may be either an array type or a single object.</p><p>Useful when working with a legacy API that returns raw allocated object(s), but you still want use a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to maintain ownership. If you have control over when allocation occurs, prefer <code>cnx_shared_ptr_new_with_allocator</code> or <code>cnx_make_shared_with_allocator</code></p>
          </div></section>
          <section class="m-doc-details" id="gac266ee041af60e3e1c0e71e5f32d2e0a"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gac266ee041af60e3e1c0e71e5f32d2e0a" class="m-doc-self">cnx_shared_ptr_free</a>(</span><span class="m-doc-wrap">T,
              self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Frees the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>, calling the associated deleter on the managed object.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type managed in the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
                <tr>
                  <td>self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to free</td>
                </tr>
              </tbody>
            </table>
<p>This should generally only need to be called explicitly in particularly rare circumstances. In typical usage, <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code>s should be declared with the <code><a href="group__cnx__shared__ptr.html#ga5dd81ba393e3fe464ddf9c23194b9c8e" class="m-doc">shared_<wbr />scoped(T)</a></code> tag, so cleanup is performed automatically when the associated <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> goes out of scope</p>
          </div></section>
          <section class="m-doc-details" id="ga451b303776892f820c2a0cfc5bf5397b"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga451b303776892f820c2a0cfc5bf5397b" class="m-doc-self">cnx_shared_ptr_release</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Releases the pointer managed by <code>self</code> from ownership.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to release ownership of its managed object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>the pointer to the object previously managed by <code>self</code></td>
                </tr>
              </tfoot>
            </table>
<p>Useful when you need to transfer ownership of the managed object from yourself to a another API that uses a different method of ownership management</p>
          </div></section>
          <section class="m-doc-details" id="ga73638203b8f1c0e8c3c354616c2dc834"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga73638203b8f1c0e8c3c354616c2dc834" class="m-doc-self">cnx_shared_ptr_reset</a>(</span><span class="m-doc-wrap">self,
              new_ptr)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Frees the object currently managed by <code>self</code>, and replaces it with the one pointed to by <code>new_ptr</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to have its managed object replaced</td>
                </tr>
                <tr>
                  <td>new_ptr</td>
                  <td>- The pointer to the object to transfer ownership of to <code>self</code></td>
                </tr>
              </tbody>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p><code>nullptr</code> is a valid pointer to pass as <code>new_ptr</code>, if you want to update <code>self</code> such that it currently manages <strong>no</strong> object</p></aside>
          </div></section>
          <section class="m-doc-details" id="gafd92b58165ad7da0a21898a9c8af19cb"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gafd92b58165ad7da0a21898a9c8af19cb" class="m-doc-self">cnx_shared_ptr_clone</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Clones the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to clone</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a clone of <code>self</code></td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="ga81220e99933dc28fb26c69b55bf0108d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga81220e99933dc28fb26c69b55bf0108d" class="m-doc-self">cnx_shared_ptr_swap</a>(</span><span class="m-doc-wrap">self,
              other_ptr)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Swaps the managed objects of <code>self</code> and the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> pointed to by <code>other_ptr</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to have its managed object swapped</td>
                </tr>
                <tr>
                  <td>other_ptr</td>
                  <td>- Pointer to the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to swap managed objects with</td>
                </tr>
              </tbody>
            </table>
<p><code>self</code> and the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> pointed to by <code>other_ptr</code> must manage the same type</p>
          </div></section>
          <section class="m-doc-details" id="ga976b2abe93731d39e7b0f5d6f451dee0"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga976b2abe93731d39e7b0f5d6f451dee0" class="m-doc-self">cnx_shared_ptr_get_deleter</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns the <code><a href="group__cnx__smart__ptrs.html#ga9290669aabf1ea806c11f2252812bf61" class="m-doc">CnxDeleter(T)</a></code> function pointer associated with the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> instantiation <code>self</code> is an instance of.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the associated deleter of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>the <code><a href="group__cnx__smart__ptrs.html#ga9290669aabf1ea806c11f2252812bf61" class="m-doc">CnxDeleter(T)</a></code> function pointer associated with <code>self</code></td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="ga69ed28fc3ca608dc7a0a8895a57d5b4d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga69ed28fc3ca608dc7a0a8895a57d5b4d" class="m-doc-self">cnx_shared_ptr_as_bool</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns whether the given <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> currently manages an object.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to check if currently manages an object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td><code>true</code> if <code>self</code> currently manages an object, otherwise <code>false</code></td>
                </tr>
              </tfoot>
            </table>
          </div></section>
          <section class="m-doc-details" id="ga1cbad558e109833820dbf0c6599f4d19"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga1cbad558e109833820dbf0c6599f4d19" class="m-doc-self">cnx_shared_ptr_get</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a pointer to the object managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the managed object of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>const correct pointer to the managed object</td>
                </tr>
              </tfoot>
            </table>
<p>This is const correct:</p><ul><li>If <code>self</code> is const, this will return a pointer-to-const of the managed object.</li><li>Otherwise, this will return a &quot;normal&quot; pointer to the managed object. If you want to explicitly get a pointer-to-const or pointer-to-not-const, use <code>cnx_shared_ptr_get_const</code> or <code>cnx_shared_ptr_get_mut</code>, respectively.</li></ul><aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p></aside>
          </div></section>
          <section class="m-doc-details" id="gab404c858c7598af460abaeaef0e83d1c"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gab404c858c7598af460abaeaef0e83d1c" class="m-doc-self">cnx_shared_ptr_get_const</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a pointer-to-const to the object managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the managed object of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>pointer-to-const to the managed object</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga820a4ceb9b1eec362fe5127851e57add"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga820a4ceb9b1eec362fe5127851e57add" class="m-doc-self">cnx_shared_ptr_get_mut</a>(</span><span class="m-doc-wrap">self)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a pointer-to-non-const to the object managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the managed object of</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>pointer-to-non-const to the managed object</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p></aside>
          </div></section>
          <section class="m-doc-details" id="gaf410eb61630d54f499318fb54404d41d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaf410eb61630d54f499318fb54404d41d" class="m-doc-self">cnx_shared_ptr_at</a>(</span><span class="m-doc-wrap">self,
              index)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a reference to the element at <code>index</code> in the array managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the element from</td>
                </tr>
                <tr>
                  <td>index</td>
                  <td>- The index of the element in the array managed by <code>self</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>const correct reference to the array element</td>
                </tr>
              </tfoot>
            </table>
<p>This is const correct:</p><ul><li>If <code>self</code> is const, this will return a reference-to-const of the array element.</li><li>Otherwise, this will return a &quot;normal&quot; reference to the array element. If you want to explicitly get a reference-to-const or reference-to-not-const, use <code>cnx_shared_ptr_at_const</code> or <code>cnx_shared_ptr_at_mut</code>, respectively.</li></ul><aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p><p>This is only available if the managed type of <code>self</code> (the <code>T</code> of its <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> template instantiation) is an array type.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga47d81a12f9dc2fe7a23842e3ef14f4bf"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga47d81a12f9dc2fe7a23842e3ef14f4bf" class="m-doc-self">cnx_shared_ptr_at_const</a>(</span><span class="m-doc-wrap">self,
              index)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a reference-to-const to the element at <code>index</code> in the array managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the element from</td>
                </tr>
                <tr>
                  <td>index</td>
                  <td>- The index of the element in the array managed by <code>self</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>reference-to-const to the array element</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p><p>This is only available if the managed type of <code>self</code> (the <code>T</code> of its <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> template instantiation) is an array type.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga12bad1b5b231a878405f74e3fbaa641e"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga12bad1b5b231a878405f74e3fbaa641e" class="m-doc-self">cnx_shared_ptr_at_mut</a>(</span><span class="m-doc-wrap">self,
              index)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Returns a reference-to-non-const to the element at <code>index</code> in the array managed by <code>self</code></p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">self</td>
                  <td>- The <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> to get the element from</td>
                </tr>
                <tr>
                  <td>index</td>
                  <td>- The index of the element in the array managed by <code>self</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>reference-to-non-const to the array element</td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>Do <strong>NOT</strong> use this to circumvent ownership. If you want to transfer ownership of the managed object, use <code>cnx_shared_ptr_release</code>. This is solely to provide a view to the managed object while maintaining ownership of it.</p><p>This is only available if the managed type of <code>self</code> (the <code>T</code> of its <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> template instantiation) is an array type.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga8a8c2a548c8eb80ebdd8217dce504c00"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga8a8c2a548c8eb80ebdd8217dce504c00" class="m-doc-self">cnx_make_shared</a>(</span><span class="m-doc-wrap">T,
              ...)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a <code>T</code> initialized with the given list of (potentially designated) initializers.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> will manage</td>
                </tr>
                <tr>
                  <td>...</td>
                  <td>- The list of initializers to initialize the <code>T</code> with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a newly allocated <code>T</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This is only available if <code>T</code> is <strong>NOT</strong> an array type. To create a sharedly owned dynamic array, use <code>cnx_make_shared_array</code> or <code>cnx_shared_ptr_new_with_capacity</code>.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga61f957c3bfb3818815ae75e9419952ed"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga61f957c3bfb3818815ae75e9419952ed" class="m-doc-self">cnx_make_shared_with_allocator</a>(</span><span class="m-doc-wrap">T,
              allocator,
              ...)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a <code>T</code> initialized with the given list of (potentially designated) initializers, allocated with the given allocator.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> will manage</td>
                </tr>
                <tr>
                  <td>allocator</td>
                  <td>- The <code><a href="structCnxAllocator.html" class="m-doc">CnxAllocator</a></code> to allocate and eventually free the <code>T</code> with</td>
                </tr>
                <tr>
                  <td>...</td>
                  <td>- The list of initializers to initialize the <code>T</code> with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a newly allocated <code>T</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This is only available if <code>T</code> is <strong>NOT</strong> an array type. To create a sharedly owned dynamic array with an associated allocator, use <code>cnx_make_shared_array_with_allocator</code> or <code>cnx_shared_ptr_new_with_capacity_and_allocator</code>.</p></aside>
          </div></section>
          <section class="m-doc-details" id="gae6e39a0e9f1e4f8e15411253b7ad4f03"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gae6e39a0e9f1e4f8e15411253b7ad4f03" class="m-doc-self">cnx_make_shared_array</a>(</span><span class="m-doc-wrap">T,
              capacity)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the array type <code>T</code> with the given initial capacity.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The array type the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> will manage. Must be a typedef to an array type (e.g.: <code>typedef i32 i32_array[];</code>)</td>
                </tr>
                <tr>
                  <td>capacity</td>
                  <td>- The capacity of the array in number of elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a newly allocated dynamic array of capacity <code>capacity</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This is only available if <code>T</code> <strong>IS</strong> an array type. To create a sharedly owned single object, use <code>cnx_make_shared</code> or <code>cnx_shared_ptr_new</code>.</p></aside>
          </div></section>
          <section class="m-doc-details" id="gaac99cb7ff1c1f18308a59f9e9a620cb4"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#gaac99cb7ff1c1f18308a59f9e9a620cb4" class="m-doc-self">cnx_make_shared_array_with_allocator</a>(</span><span class="m-doc-wrap">T,
              capacity,
              allocator)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Creates a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing the array type <code>T</code> with the given initial capacity, allocated with the given allocator.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The array type the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> will manage. Must be a typedef to an array type (e.g.: <code>typedef i32 i32_array[];</code>)</td>
                </tr>
                <tr>
                  <td>capacity</td>
                  <td>- The capacity of the array in number of elements</td>
                </tr>
                <tr>
                  <td>allocator</td>
                  <td>- The <code><a href="structCnxAllocator.html" class="m-doc">CnxAllocator</a></code> to allocate and eventually free the array with</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> managing a newly allocated dynamic array of capacity <code>capacity</code></td>
                </tr>
              </tfoot>
            </table>
<aside class="m-note m-info"><h4>Note</h4><p>This is only available if <code>T</code> <strong>IS</strong> an array type. To create a sharedly owned single object with an associated allocator, use <code>cnx_make_shared_with_allocator</code> or <code>cnx_shared_ptr_new_with_allocator</code>.</p></aside>
          </div></section>
          <section class="m-doc-details" id="ga5dd81ba393e3fe464ddf9c23194b9c8e"><div>
            <h3>
              <span class="m-doc-wrap-bumper">#define <a href="#ga5dd81ba393e3fe464ddf9c23194b9c8e" class="m-doc-self">shared_scoped</a>(</span><span class="m-doc-wrap">T)</span>
              <div class="m-doc-include m-code m-inverted m-text-right"><span class="cp">#include</span> <a class="cpf" href="SharedPtrDef_8h.html">&lt;include/Cnx/shared_ptr/SharedPtrDef.h&gt;</a></div>
            </h3>
            <p>Declare a <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> with this declaration attribute/type to ensure it (and its managed object) is automatically freed when the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code> goes out of scope.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>- The type managed by the <code><a href="group__cnx__shared__ptr.html#ga31a460baee7771717b4a1b7d39426338" class="m-doc">CnxSharedPtr(T)</a></code></td>
                </tr>
              </tbody>
            </table>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Cnx A Proof-of-Concept For A Modern Standard Library for GNU C23. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.4 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
