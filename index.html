<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cnx A Proof-of-Concept For A Modern Standard Library for GNU C (11+)</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Cnx <span class="m-thin">A Proof-of-Concept For A Modern Standard Library for GNU C (11+)</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li><a href="annotated.html">Classes</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Cnx
        </h1>
<p><a name="md_README"></a> Cnx is a GNU C (11+) library providing type-safe collections and ergonomic features typical in higher-level languages, to C. It aims to be a proof-of-concept view of what a more modern standard (or at least widely used base) library could look like in the future if it only had to support C23, with much more modern abstractions and ergonomics over the standard C library. It is currently under active development and has not yet hit a <strong>stable</strong> release point.</p><p>Some features of Cnx include:</p><ul><li>Type-Safe collections implemented (mostly) as manually instantiated templates. Currently implemented collections include <code><a href="structCnxString.html" class="m-doc">CnxString</a></code>, <code><a href="group__cnx__vector.html#ga20ef1dda4889be96e378b40dfe573619" class="m-doc">CnxVector(T)</a></code>, and <code><a href="group__cnx__array.html#gaaa58177bcbc426c1e85308132dd07a21" class="m-doc">CnxArray(T, N)</a></code></li><li>Error handling facilities similar to Rust and <code>boost::outcome</code> with equivalent semantics and similar API to Rust, via <code><a href="structCnxError.html" class="m-doc">CnxError</a></code> and <code><a href="group__cnx__result.html#gae75db0a7127412b9b98576a3766b7f4f" class="m-doc">CnxResult(T)</a></code></li><li>Optional value type, <code><a href="group__cnx__option.html#ga115e240208ecd9d6c00cbe9dd8993f7a" class="m-doc">CnxOption(T)</a></code> based on Rust&#x27;s <code>std::option::Option</code> with equivalent semantics and similar API to Rust</li><li>Facilities for defining, implementing, and using polymorphic interfaces via Traits</li><li>Iterators, Ranges, and <code>foreach</code> loops (equivalent to C++&#x27;s <code>for(elem : collection)</code>)</li><li>Human-readable (no more having to remember which character combination corresonds to which type in <code>printf</code>), type-safe string formatting and formatted I/O via the <code><a href="structCnxFormat.html" class="m-doc">CnxFormat</a></code> Trait</li><li>More intuitive, more performant file API with <code><a href="structCnxFile.html" class="m-doc">CnxFile</a></code>, along with simple file system interaction API with <code>CnxPath</code></li></ul><section id="autotoc_md1"><h5><a href="#autotoc_md1">Why not standard C?</a></h5><p>Cnx makes heavy use of <code>__auto_type</code> and some of its features are only possible with it. It also uses statement-expressions for several features and <code>__attribute__(cleanup)</code> for scoped destruction. It could be refactored to be Standard C in C23 or a subsequent standard, if C gets <code>auto</code>, <code>typeof</code>, <code>__VA_OPT__</code>, lamdas, and defer.</p></section><section id="autotoc_md2"><h5><a href="#autotoc_md2">Can I use this in production?</a></h5><p>Can you? Sure! Should you? Probably not yet. Testing right now is minimal and only enough to ensure a majority of functionality works in the general case, and is definitely not thorough enough yet to ensure reliability in production.</p></section><section id="autotoc_md3"><h2><a href="#autotoc_md3">Documentation</a></h2><p>You can view the documentation <a href="https://braxtons12.github.io/Cnx/">here</a></p></section><section id="autotoc_md4"><h2><a href="#autotoc_md4">Getting Started</a></h2><p>Cnx uses CMake, and incorporating it into your project is easy!</p><p>First, set up your CMake project. In <code>CMakeLists.txt</code>:</p><pre class="m-code"><span class="nb">FetchContent_Declare</span><span class="p">(</span><span class="s">Cnx</span>
        <span class="s">GIT_REPOSITORY</span> <span class="s2">&quot;https://github.com/braxtons12/Cnx&quot;</span>
        <span class="s">GIT_TAG</span> <span class="s2">&quot;0.1.0&quot;</span>
        <span class="p">)</span>

<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">Cnx</span><span class="p">)</span>

<span class="c">### Setup your target......</span>

<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">your_target</span> <span class="s">Cnx</span><span class="p">)</span></pre><p>Then, include your desired headers, either the main header, <code><a href="Cnx_8h.html" class="m-doc">Cnx/<wbr />Cnx.h</a></code>, for everything, or individual ones for granular imports.</p><section id="autotoc_md5"><h3><a href="#autotoc_md5">Example</a></h3><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&lt;Cnx/CnxDef.h&gt;</span><span class="cp"></span>
<span class="cp">#define VECTOR_INCLUDE_DEFAULT_INSTANTIATIONS TRUE</span>
<span class="cp">#define RANGE_INCLUDE_DEFAULT_INSTANTIATIONS TRUE</span>
<span class="cp">#include</span> <span class="cpf">&lt;Cnx/Cnx.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">transform</span><span class="p">(</span><span class="n">i32</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">elem</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">i32</span> <span class="nf">main</span><span class="p">(</span><span class="n">i32</span> <span class="n">argc</span><span class="p">,</span> <span class="n">const_cstring</span><span class="o">*</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// vector is already instantiated for builtins like `i32` and some provided types like `CnxString`,</span>
    <span class="c1">// so, we can just use it directly here</span>
    <span class="n">let_mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">cnx_vector_new_with_capacity</span><span class="p">(</span><span class="n">i32</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

    <span class="c1">// insert 10 elements, 0 through 9, into the vector</span>
    <span class="n">ranged_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cnx_vector_push_back</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// print information about the vector (size, capacity, whether it is currently in</span>
    <span class="c1">// small-size-optimization mode) to `stdout`, followed by a newline.</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">as_format_t</span><span class="p">(</span><span class="n">CnxVector</span><span class="p">(</span><span class="n">i32</span><span class="p">),</span> <span class="n">vec</span><span class="p">));</span>

    <span class="c1">// print each element, followed by a newline, to `stdout`</span>
    <span class="c1">// prints 0 through 9</span>
    <span class="n">foreach</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>    
    <span class="p">}</span>

    <span class="c1">// transform the elements in the vector with the above-defined `transform` function</span>
    <span class="c1">// and returns a view of the vector as a `CnxRange(i32)` (that we ignore)</span>
    <span class="n">cnx_transform</span><span class="p">(</span><span class="n">i32</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">transform</span><span class="p">);</span>

    <span class="c1">// print each element, followed by a newline, to `stdout`</span>
    <span class="c1">// prints multiples of 3 from 0 through 27</span>
    <span class="n">foreach</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>    
    <span class="p">}</span>
<span class="p">}</span></pre></section><section id="autotoc_md6"><h3><a href="#autotoc_md6">Collections</a></h3><p>Cnx collections provide type-safety, iterators, the ability to use user-provided default and copy constructors, and destructors, for stored types, and, where applicable, are allocator aware. For more details on collections, see the documentation on the specific collection.</p></section><section id="autotoc_md7"><h3><a href="#autotoc_md7">Formatting</a></h3><p>String formatting uses a very simple syntax. In a format string, <code>{}</code> specifies that an argument should be formatted and placed in that location. Format specifiers can be placed inside the braces to specify the way the argument should be formatted. Currently supported specifiers are limited:</p><ul><li><code>{}</code>: The default format</li><li><code>{d}</code>: Format the associated argument as a decimal (base-10) number. This is the default for integral types. Only applicable to signed, unsigned, and floating point numeric types</li><li><code>{dyy}</code>: Format a floating point number as a decimal (base-10) number, with <code>yy</code> digits after the decimal point</li><li><code>{e}</code>: Format a floating point number as scientific notation with the default number of significant figures (3) after the decimal point. This is the default for floating point types.</li><li><code>{eyy}</code>: Format a floating point number as scientific notation with <code>yy</code> number of significant figures after the decimal point.</li><li><code>{x}</code>: Format an integral number as lower-case hexadecimal</li><li><code>{X}</code>: Format an integral number as upper-case hexadecimal</li></ul><p>Providing a specifier that is invalid for the associated argument will result in a runtime assert in debug builds and unspecified behavior in release builds (for builtin and provided types).</p><p>For more details on string formatting, see the documentation for the <code><a href="structCnxFormat.html" class="m-doc">CnxFormat</a></code> Trait, <code><a href="group__format.html#ga8875030a5ae8a1d926bbac6e184c6791" class="m-doc">cnx_<wbr />format(format_<wbr />string, ...)</a></code>, and the <a href="group__format.html" class="m-doc">CnxFormat</a> module.</p></section><section id="autotoc_md8"><h3><a href="#autotoc_md8">Performance</a></h3><p>I know, you&#x27;re probably thinking &quot;So, something that nice can&#x27;t be fast right? What&#x27;s the cost?&quot; And the answer is: not necessarily anything. Generally, performance is faster than traditional standard C functionality, even with the increased ergonomics and composability gained from using the library&#x27;s features.</p><p>We have two benchmarks to showcase this. The first pits <code>println</code> against <code>printf</code> from the standard library. The second pits the Cnx file API against the standard library&#x27;s <code>fprintf</code>. For the code used for each benchmark and more detailed results (Std. Dev., Median, individual runs), see the project/code in the &quot;benchmark&quot; subfolder.</p><p>The implementation of <code>println</code> makes heavy use of most of the functionality presented in the example (except for <code><a href="group__ranges.html#ga65e27f15e85a18ea3b930790ca4a27e9" class="m-doc">CnxRange(T)</a></code>), as well as the <code>Result(T)</code> type, which means it&#x27;s using many of the facilities currently provided by the library. Meanwhile, the file API uses everything <code>println</code> does, in addition to providing a safer and more ergonomic API for file manipulation than the standard library, while also taking better advantage of features like buffering to further improve performance. So, lets start by taking a look at the benchmark comparing the relative speed of <code>println</code> to <code>printf</code>.</p><p>This benchmark consisted of printing out N strings to <code>stdout</code>, each consisting of:</p><ul><li>the Mth multiple of 1024, unsigned</li><li>the Mth multiple of negative 1024</li><li>the Mth multiple of negative 1024.1024</li><li>a <code><a href="structCnxString.html" class="m-doc">CnxString</a></code> pre-initialized to &quot;This is a string&quot;</li></ul><p>where M is in [0, N)</p><p>It was run 10 times for each N, with the average of the 10 runs taken. The benchmark was performed with builds from both Clang 14.0.0 and GCC 11.2.0, and with both the default system allocator and jemalloc.<br />All benchmarks were run on an Intel Core i7-8750H with 16GB RAM running EndeavorOS (Arch Linux) with the Zen Kernel 5.17.5-zen1-1-zen.<br />Clang builds were compiled with &quot;-flto -Ofast -ffast-math -DNDEBUG&quot;.<br />GCC builds were compiled with &quot;-flto -ffat-lto-objects -Ofast -DNDEBUG&quot; All numbers are relative performance compared to <code>printf</code></p><p>While these numbers are Linux specific, in general you can expect comparable numbers on Windows using native clang, and even better numbers using MinGW, but benchmark on your specific platform for platform specific numbers.</p><section id="autotoc_md9"><h4><a href="#autotoc_md9">&lt;tt&gt;println&lt;/tt&gt; vs &lt;tt&gt;printf&lt;/tt&gt; Results</a></h4><table class="m-table"><thead><tr><th>N</th><th>Clang + System Allocator</th><th>Clang + jemalloc</th><th>GCC + System Allocator</th><th>GCC + jemalloc</th></tr></thead><tbody><tr><td>1</td><td>1.6316</td><td>1.9758</td><td>2.9815</td><td>2.1675</td></tr><tr><td>10</td><td>1.8762</td><td>1.4501</td><td>1.7318</td><td>1.6026</td></tr><tr><td>100</td><td>1.2305</td><td>1.2312</td><td>1.0868</td><td>1.0535</td></tr><tr><td>1000</td><td>1.1330</td><td>1.1666</td><td>1.0652</td><td>1.0045</td></tr><tr><td>10000</td><td>1.3016</td><td>1.0991</td><td>1.0266</td><td>1.0610</td></tr><tr><td>100000</td><td>1.1154</td><td>1.1374</td><td>1.0509</td><td>1.0517</td></tr><tr><td>average</td><td>1.3814</td><td>1.3434</td><td>1.4905</td><td>1.3235</td></tr></tbody></table><p>As you can see, on <strong>average</strong> you can expect around a 38% performance <strong>boost</strong> compared to <code>printf</code>. For infrequent I/O you can expect up to a 200% performance <strong>boost</strong>, and for high frequency I/O you can expect around a 10% performance <strong>boost</strong>. If you dig into the detailed benchmark results, you&#x27;ll see that in general you can expect it to be fairly allocator insensitive with clang (somewhat less so with GCC), and that building with clang and using the default system allocator is the most <strong>consistently</strong> fast option to use.</p><p>So not only does using Cnx for string formatting and I/O give greatly improved ergonomics and composability over traditional methods, you also get a performance increase too!</p><p>Now for the benchmark pitting the file API against <code>fprintf</code>. This is nearly identical to the previous benchmark as fas as setup and methodologies go. The only difference is that the strings are printed to two separate files, one for the file API and one for <code>fprintf</code>, each using the API being benchmarked for performing the string formatting and I/O.</p></section><section id="autotoc_md10"><h4><a href="#autotoc_md10">Cnx File API vs &lt;tt&gt;fprintf&lt;/tt&gt; Results</a></h4><table class="m-table"><thead><tr><th>N</th><th>Clang + System Allocator</th><th>Clang + jemalloc</th><th>GCC + System Allocator</th><th>GCC + jemalloc</th></tr></thead><tbody><tr><td>1</td><td>5.2710</td><td>6.6535</td><td>3.6145</td><td>5.0965</td></tr><tr><td>10</td><td>3.6245</td><td>3.3975</td><td>3.2620</td><td>2.3175</td></tr><tr><td>100</td><td>2.4345</td><td>2.7620</td><td>1.6815</td><td>1.6745</td></tr><tr><td>1000</td><td>1.5145</td><td>1.5195</td><td>1.1050</td><td>1.1800</td></tr><tr><td>10000</td><td>1.3485</td><td>1.3350</td><td>0.9645</td><td>1.0255</td></tr><tr><td>100000</td><td>1.3335</td><td>1.3115</td><td>1.0365</td><td>1.0005</td></tr><tr><td>average</td><td>2.5878</td><td>2.8298</td><td>1.9440</td><td>2.0491</td></tr></tbody></table><p>So, on <strong>average</strong> you can expect around a 100% performance <strong>boost</strong> compared to <code>fprintf</code>. For infrequent I/O you can expect at least a 250% performance <strong>boost</strong>, or even higher, and for high frequency I/O you can expect around a 17% performance <strong>boost</strong>. You can see that, particularly at very sparse workloads, taking better advantage of buffering the way Cnx&#x27;s file API does leads to significant performance improvements over the standard functionality. If you dig into the detailed benchmark results, you&#x27;ll see that allocator choice plays a bigger role here than with <code>println</code>, in particular at very sparse workloads. Unforntunately, GCC begins to sputter out as the workload increases, and in some cases actually manages to perform worse than the standard library functions. However, the gcc + system allocator pairing does the most consistent performance (lowest average standard deviation and smallest abs(averaged median - averaged average)). That said, it&#x27;s also the slowest pairing, and the clang + system allocator pairing comes in at a close second in terms of consitency while still being the second fastest overall. Lastly, you&#x27;ll see the clang + jemalloc pairing is the most <strong>consistently</strong> fast option to use (highest average and highest averaged median).</p><p>This was the performance for formatting builtin types (u32, i32, f32, cstring. <code><a href="structCnxString.html" class="m-doc">CnxString</a></code>&#x27;s <code><a href="structCnxFormat.html" class="m-doc">CnxFormat</a></code> implementation simply forwards itself, so it&#x27;s about as expensive as passing a cstring to <code>printf</code>), but it would be reasonable to expect this to translate to custom types as well.</p></section></section><section id="autotoc_md11"><h3><a href="#autotoc_md11">Testing</a></h3><p>Tests are set up as a separate &quot;Cnx-Test&quot; target in the CMake project.<br />To run the tests, simply configure and build the test target, then run the resulting &quot;Cnx-Test&quot; executable.<br />Please feel free to submit new tests!</p><p>Inside the Cnx main directory:</p><pre class="m-code">cmake -B build -G <span class="s2">&quot;Ninja&quot;</span>
cmake --build build --target Cnx-Test
./build/Cnx-Test</pre></section><section id="autotoc_md12"><h3><a href="#autotoc_md12">Contributing</a></h3><p>Feel free to submit issues, pull requests, etc.!<br />When contributing code, please adhead to the project <code>.clang-tidy</code>, follow the project <code>.clang-format</code> (except in judicious cases of macros ruining things), prefer <code>let</code> or <code>let_mut</code> over explicit typing (where possible), and prefer simplicity and correctness over performance by default.</p></section><section id="autotoc_md13"><h3><a href="#autotoc_md13">License</a></h3><p>Cnx uses the MIT license.</p></section><section id="autotoc_md14"><h3><a href="#autotoc_md14">Special Thanks</a></h3><p>Special thanks should be given to the Rust team and C++ standardization committee, and contributors of each, for creating great programming languages that have inspired a lot of the functionality provided by this library. Thanks should also go to <a href="https://github.com/TotallyNotChase/">TotallyNotChase</a> for inspiring the design of the Trait system and Iterators with <a href="https://github.com/TotallyNotChase/c-iterators/">c-iterators</a> and to <a href="https://github.com/Hirrolot/">Hirrolot</a> for also inspiring the Trait system with <a href="https://github.com/Hirrolot/interface99">interface99</a>.</p></section></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Cnx A Proof-of-Concept For A Modern Standard Library for GNU C (11+). Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.4 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
